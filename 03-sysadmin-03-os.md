1. Какой системный вызов делает команда cd? 

``` chdir("/tmp")```    


2. Используя ```strace``` выясните, где находится база данных ```file``` на основании которой она делает свои догадки.

```
openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3
```
плюс к этому 
```
openat(AT_FDCWD, "/usr/lib/locale/locale-archive", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/usr/share/locale/locale.alias", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/usr/lib/locale/C.UTF-8/LC_CTYPE", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache", O_RDONLY) = 3
```

3. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).  
>Выполним команду ```lsof -p <PID>```.  
Найдём файл с пометкой `delete`. (`python3 1495 vagrant    `**3**`r   REG  253,0        5 1835056 /tmp/do_not_delete_me (deleted)`)  
Выполним ```echo ''> /proc/<PID>/fd/<FD number>```    


4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?  
>"Зомби" процессы, в отличии от "сирот" освобождают свои ресурсы, но не освобождают запись в таблице процессов. 
запись освободиться при вызове wait() родительским процессом. 




5. В iovisor BCC есть утилита `opensnoop`:
```
root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
/usr/sbin/opensnoop-bpfcc
```
На какие файлы вы увидели вызовы группы `open` за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04.

```
root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
/usr/sbin/opensnoop-bpfcc
root@vagrant:~# /usr/sbin/opensnoop-bpfcc
PID    COMM               FD ERR PATH
948    vminfo              6   0 /var/run/utmp
632    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
632    dbus-daemon        20   0 /usr/share/dbus-1/system-services
632    dbus-daemon        -1   2 /lib/dbus-1/system-services
632    dbus-daemon        20   0 /var/lib/snapd/dbus-1/system-services/
```
6. Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.  
>системный вызов uname()  
Цитата :  
>     *Part of the utsname information is also accessible  via  /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.*

7. Чем отличается последовательность команд через `;` и через `&&` в bash? Есть ли смысл использовать в bash `&&`, если применить `set -e`?
>`&&` - условный оператор   
`;`  - разделитель последовательных команд  
`test -d /tmp/some_dir && echo Hi` - в данном случае `echo` сработает только при успешном завершении команды `test`  
`set -e` - прерывает сессию при любом ненулевом значении исполняемых команд в последовательности кроме последней. 
Применение `&&`  вместе с `set -e` - нет смысла. При ошибке выполнение команд прекратится.

8. Из каких опций состоит режим bash `set -euxo pipefail` и почему его хорошо было бы использовать в сценариях? 
>`-e` прерывает выполнение исполнения при ошибке любой команды кроме последней в последовательности   
`-x` вывод трейса простых команд   
`-u` неустановленные/незаданные параметры и переменные считаются как ошибки, с выводом в `stderr` текста ошибки и выполнит завершение не интерактивного вызова  
`-o pipefail` возвращает код возврата набора/последовательности команд, ненулевой при последней команды или 0 для успешного выполнения команд.  
Для сценария повышает детализацию вывода ошибок(логирования) 
и завершит сценарий при наличии ошибок, на любом этапе выполнения сценария, кроме последней завершающей команды

9.Используя `-o stat` для `ps`, определите, какой наиболее часто встречающийся статус у процессов в системе. В `man ps` ознакомьтесь `(/PROCESS STATE CODES)` что значат дополнительные к основной заглавной буквы статуса процессов.   
```
vagrant@vagrant:~$ ps -o stat
STAT
Ss
R+
```
`S` - спящие процессы
`R` - запущенные процессы. Дополнительные символы это доп характеристики, например приоритет.